/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This copy of FASTRPC is licensed to you under the terms described in the
 * FASTRPC_LICENSE file included in this distribution.
 *
 *************************************************************************/
// TODO Cambiar cabecera.

group TypesHeader;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, ".h"], description=["This header file contains the declaration of the described types in the IDL file."])$

#ifndef _$ctx.filename;format="toUpper"$_H_
#define _$ctx.filename;format="toUpper"$_H_

// TODO Poner en el contexto.
$if(ctx.fastrpcProduct)$
#include "$ctx.product$/exceptions/UserException.h"
$endif$

$ctx.directIncludeDependencies : {include | #include "$include$.h"}; separator="\n"$

#include <stdint.h>
#include <array>
#include <string>
#include <vector>

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define eProsima_user_DllExport __declspec( dllexport )
#else
#define eProsima_user_DllExport
#endif
#else
#define eProsima_user_DllExport
#endif

$if(ctx.cdr)$
namespace eprosima
{
    namespace fastcdr
    {
        class Cdr;
    }
}

$elseif(ctx.fastcdr)$
namespace eprosima
{
    namespace fastcdr
    {
        class FastCdr;
    }
}

$endif$

$definitions; separator="\n"$

#endif // _$ctx.filename;format="toUpper"$_H_
>>

// TODO name -> module
module(ctx, module, definition_list) ::= <<
namespace $module.name$
{
    $definition_list$
}
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

interface(ctx, interface, export_list) ::= <<
/*!
 * @brief This class represents the interface $interface.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
namespace $interface.name$
{
    $export_list$
}
>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, exception) ::= <<
$if(ctx.fastrpcProduct)$
/*!
 * @brief This class implementes the user exception $exception.scopedname$
 * @ingroup $ctx.trimfilename$
 */
class eProsima_user_DllExport $exception.name$ : public eprosima::rpc::exception::UserException
{
public:
    
    //! @brief Default constructor.
	$exception.name$();

    /*!
     * @brief Copy constructor.
     * @param ex Exception to be copied.
     */
	$exception.name$(const $exception.name$ &ex);

    /*!
     * @brief Move constructor.
     * @param ex Exception to be moved.
     */
	$exception.name$($exception.name$&& ex);

    /*!
     * @brief Copy assignment.
     * @param ex Exception to be copied.
     */
	$exception.name$& operator=(const $exception.name$ &ex);

    /*!
     * @brief Move assignment.
     * @param ex Exception to be moved.
     */
	$exception.name$& operator=($exception.name$&& ex);
	
    //! @brief Destructor.
	virtual ~$exception.name$() throw();

    //! @brief This function throws the object as exception.
	virtual void raise() const;

    $exception.members:{ member |$public_member_declaration(member=member)$}; separator="\n"$
    
    $size_functions(exception)$

    $serialization_functions(exception)$
    
private:
	// Exception members
    $exception.members:{ member |$private_member_declaration(member=member)$}; separator="\n"$
};
$endif$
>>

operation(ctx, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, const) ::= <<
const $const.typeCode.cppTypename$ $const.name$ = $const.value$;
>>

typedef_decl(ctx, typedefs) ::= <<
$typedefs : { typedef |typedef $typedef.typedefContentTypeCode.cppTypename$ $typedef.name$;}; separator="\n"$
>>

struct_type(ctx, struct) ::= <<
/*!
 * @brief This class represents the structure $struct.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class eProsima_user_DllExport $struct.name$
{
public:

    /*!
     * @brief Default constructor.
     */
    $struct.name$();
    
    /*!
     * @brief Default destructor.
     */
    ~$struct.name$();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$(const $struct.name$ &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$($struct.name$ &&x);
    
    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$& operator=(const $struct.name$ &x);
    
    /*!
     * @brief Move assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$& operator=($struct.name$ &&x);
    
    $struct.members:{$public_member_declaration(it)$}; separator="\n"$
    
    $size_functions(struct)$

    $serialization_functions(struct)$
    
private:
    $struct.members:{$private_member_declaration(it)$}; separator="\n"$
};
>>

union_type(ctx, union) ::= <<
/*!
 * @brief This class represents the union $union.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class eProsima_user_DllExport $union.name$
{
public:

    /*!
     * @brief Default constructor.
     */
    $union.name$();
    
    /*!
     * @brief Default destructor.
     */
    ~$union.name$();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$(const $union.name$ &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$($union.name$ &&x);
    
    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$& operator=(const $union.name$ &x);
    
    /*!
     * @brief Move assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$& operator=($union.name$ &&x);
    
    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception eprosima::fastcdr::BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    void _d($union.discriminator.cppTypename$ __d);
    
    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    $union.discriminator.cppTypename$ _d() const;
    
    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    $union.discriminator.cppTypename$& _d();
    
    $union.members:{$public_unionmember_declaration(it)$}; separator="\n"$
    
    $size_functions(union)$

    $serialization_functions(union)$
    
private:
    $private_declaration(typecode=union.discriminator, name="_d")$
    
    $union.members:{$private_member_declaration(it)$}; separator="\n"$
};
>>

enum_type(ctx, enum) ::= <<
/*!
 * @brief This class represents the enumeration $enum.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
enum $enum.name$ : uint32_t
{
    $enum.members:{$it.name$}; separator=",\n"$
};
>>

/***** Utils *****/

public_member_declaration(member) ::= <<
$if(member.typecode.primitive)$
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
inline void $member.name$($member.typecode.cppTypename$ _$member.name$)
{
    m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
inline $member.typecode.cppTypename$ $member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
inline $member.typecode.cppTypename$& $member.name$()
{
    return m_$member.name$;
}
$else$
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
inline void $member.name$(const $member.typecode.cppTypename$ &_$member.name$)
{
    m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
inline void $member.name$($member.typecode.cppTypename$ &&_$member.name$)
{
    m_$member.name$ = std::move(_$member.name$);
}

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 */
inline const $member.typecode.cppTypename$& $member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
inline $member.typecode.cppTypename$& $member.name$()
{
    return m_$member.name$;
}
$endif$
>>

private_member_declaration(member) ::= <<$private_declaration(typecode=member.typecode, name=member.name)$>>

public_unionmember_declaration(member) ::= <<
$if(member.typecode.primitive)$
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
void $member.name$($member.typecode.cppTypename$ _$member.name$);

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 * @exception eprosima::fastcdr::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$member.typecode.cppTypename$ $member.name$() const;

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception eprosima::fastcdr::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$member.typecode.cppTypename$& $member.name$();
$else$
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
void $member.name$(const $member.typecode.cppTypename$ &_$member.name$);

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
void $member.name$($member.typecode.cppTypename$ &&_$member.name$);

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception eprosima::fastcdr::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
const $member.typecode.cppTypename$& $member.name$() const;

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception eprosima::fastcdr::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$member.typecode.cppTypename$& $member.name$();
$endif$
>>

private_declaration(typecode, name) ::= <<
$typecode.cppTypename$ m_$name$;
>>


/*! TODO Quitado de FastBuffers porque no encaja con las excepciones de fastrpc.
 * @brief This function calculates the space needed to serialize a type $type.scopedname$.
 *        For all types with a variable size (strings, sequences) and without a maximum limit, this function uses
 *        255 as maximum limit.
 *
 inline
 size_t getMaxSerializedSize() { return $type.maxSerializedSize$;}
 
 *!
 * @brief This function calculates the space needed to serialize a type $type.scopedname$ without alignment.
 *        For all types with a variable size (strings, sequences) and without a maximum limit, this function uses
 *        255 as maximum limit.
 *
 inline
 size_t getMaxSerializedSizeWithoutAlign(){ return $type.maxSerializedSizeWithoutAlignment$;}
 */

size_functions(type) ::= <<
$if(ctx.anyCdr)$
/*!
 * @brief This function returns the maximum serialized size of an object
 * depending on the buffer alignment.
 * @param current_alignment Buffer alignment.
 * @return Maximum serialized size.
 */
static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

$endif$
>>

serialization_functions(type) ::= <<
$if(ctx.cdr)$
/*!
 * @brief This function serializes an object using CDR serialization.
 * @param cdr CDR serialization object.
 */
void serialize(eprosima::fastcdr::Cdr &cdr) const;

/*!
 * @brief This function deserializes an object using CDR serialization.
 * @param cdr CDR serialization object.
 */
void deserialize(eprosima::fastcdr::Cdr &cdr);

$elseif(ctx.fastcdr)$
/*!
 * @brief This function serializes an object using FastCDR serialization.
 * @param cdr FastCDR serialization object.
 */
void serialize(eprosima::fastcdr::FastCdr &cdr) const;

/*!
 * @brief This function deserializes an object using FastCDR serialization.
 * @param cdr FastCDR serialization object.
 */
void deserialize(eprosima::fastcdr::FastCdr &cdr);

$endif$
>>
