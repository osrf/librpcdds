/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file CalculatorDDSProtocol.cxx
 * This source file contains the definition of the protocol used to create DDS messages.
 *
 * This file was generated by the tool rpcddsgen.
 */

//TODO Remove when only one VS project will be generated
#if defined(_WIN32) && defined(NDDS_USER_DLL_EXPORT)
class __declspec(dllimport) DDSDomainEntity;
class __declspec(dllimport) DDSEntity;
#endif
#include "CalculatorDDSProtocol.h"
#include "rpcdds/transports/Transport.h"
#include "rpcdds/transports/dds/ProxyTransport.h"
#include "rpcdds/transports/dds/components/ProxyProcedureEndpoint.h"
#include "CalculatorDDSAsyncSupport.h"
#include "rpcdds/transports/dds/ServerTransport.h"
#include "rpcdds/transports/dds/components/ServerProcedureEndpoint.h"
#include "rpcdds/exceptions/Exceptions.h"
#include "CalculatorRequestReplyPlugin.h"
#include "CalculatorRequestReplySupport.h"
using namespace eprosima::rpc;
using namespace ::protocol::dds;
using namespace ::transport;
using namespace ::exception;

CalculatorProtocol::CalculatorProtocol() : ::protocol::CalculatorProtocol(), m_ddsTransport(NULL)
, Calculator_str("Calculator")
, Calculator_pe(NULL), Calculator_se(NULL)
{
}

CalculatorProtocol::~CalculatorProtocol()
{
}

bool CalculatorProtocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "DDS") == 0)
    {
        m_ddsTransport = dynamic_cast<eprosima::rpc::transport::dds::Transport*>(&transport);
        
        m_ddsTransport->initialize();
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

// TODO Si falla que elimine los creados.
bool CalculatorProtocol::activateInterface(const char* interfaceName)
{
    const char *requesttypeName = NULL, *replytypeName = NULL;

    if(m_ddsTransport != NULL)
    {
        TransportBehaviour behaviour = dynamic_cast<Transport*>(m_ddsTransport)->getBehaviour();
        
        if(strcmp(interfaceName, "Calculator") == 0)
        {
            requesttypeName = Calculator_RequestTypeSupport::get_type_name();
    
            if(Calculator_RequestTypeSupport::register_type(m_ddsTransport->getParticipant(), requesttypeName) != DDS::RETCODE_OK)
            {
                return false;
            }
            
            replytypeName = Calculator_ReplyTypeSupport::get_type_name();
    
            if(Calculator_ReplyTypeSupport::register_type(m_ddsTransport->getParticipant(), replytypeName) != DDS::RETCODE_OK)
            {
                return false;
            }
            
            if(behaviour == ::transport::PROXY_BEHAVIOUR)
            {
                Calculator_pe = dynamic_cast<eprosima::rpc::transport::dds::ProxyProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(Calculator_str,
                requesttypeName,
                replytypeName,
                false,
                (::transport::dds::Transport::Create_data)Calculator_ReplyPluginSupport_create_data,
                (::transport::dds::Transport::Copy_data)Calculator_ReplyPluginSupport_copy_data,
                (::transport::dds::Transport::Destroy_data)Calculator_ReplyPluginSupport_destroy_data,
                NULL,
                sizeof(Calculator_Reply)
                ));
            }
            if(behaviour == ::transport::SERVER_BEHAVIOUR)
            {
                Calculator_se = dynamic_cast<eprosima::rpc::transport::dds::ServerProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(Calculator_str,
                    replytypeName,
                    requesttypeName,
		            false,
                    (::transport::dds::Transport::Create_data)Calculator_RequestPluginSupport_create_data,
                    (::transport::dds::Transport::Copy_data)Calculator_RequestPluginSupport_copy_data,
                    (::transport::dds::Transport::Destroy_data)Calculator_RequestPluginSupport_destroy_data,
                    CalculatorProtocol::Calculator_serve,
                    sizeof(Calculator_Request)));
            }
        }
        
        return true;
    }
    else
    {
      // TODO Trace.
    }
    
    return false;
}

void CalculatorProtocol::Calculator_serve(eprosima::rpc::protocol::Protocol &protocol,
    void *_data , eprosima::rpc::transport::Endpoint *endpoint)
{
    CalculatorProtocol &_protocol = dynamic_cast<CalculatorProtocol&>(protocol);
    Calculator_Request &requestData = *(Calculator_Request*)_data;

    switch(requestData.request._d)
    {
                case 0xCBC6CEAA:
                {
                DDS_Long  value1 = 0;
                DDS_Long  value2 = 0;
                DDS_Long  return_ = 0;   
                Calculator_Reply replyData;
                memcpy(replyData.header.request_id.guid.value, requestData.header.request_id.guid.value, sizeof(replyData.header.request_id.guid.value));
                replyData.header.request_id.sequence_number = requestData.header.request_id.sequence_number;

                replyData.reply._d = 0xCBC6CEAA;


                value1 = requestData.request._u.addition.value1;
                value2 = requestData.request._u.addition.value2;

                try
                {
                    if(_protocol._Calculator_impl != NULL)
                    {
                        return_ = _protocol._Calculator_impl->addition(value1, value2);

                        replyData.reply._u.addition._d = 0;

                        replyData.reply._u.addition._u.out_.return_ = return_;

                        _protocol.Calculator_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //memset((char*)&replyData + sizeof(replyData.header), 0, sizeof(replyData) - sizeof(replyData.header));
                    replyData.reply._u.addition._d = 1;
                    replyData.reply._u.addition._u.sysx_ = (SystemExceptionCode)SERVER_INTERNAL_ERROR;

                    _protocol.Calculator_se->sendReply(&replyData);
                }

                Calculator_Request_finalize(&requestData);


                }
                break;
                
                case 0xCA019A14:
                {
                DDS_Long  value1 = 0;
                DDS_Long  value2 = 0;
                DDS_Long  return_ = 0;   
                Calculator_Reply replyData;
                memcpy(replyData.header.request_id.guid.value, requestData.header.request_id.guid.value, sizeof(replyData.header.request_id.guid.value));
                replyData.header.request_id.sequence_number = requestData.header.request_id.sequence_number;

                replyData.reply._d = 0xCA019A14;


                value1 = requestData.request._u.subtraction.value1;
                value2 = requestData.request._u.subtraction.value2;

                try
                {
                    if(_protocol._Calculator_impl != NULL)
                    {
                        return_ = _protocol._Calculator_impl->subtraction(value1, value2);

                        replyData.reply._u.subtraction._d = 0;

                        replyData.reply._u.subtraction._u.out_.return_ = return_;

                        _protocol.Calculator_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //memset((char*)&replyData + sizeof(replyData.header), 0, sizeof(replyData) - sizeof(replyData.header));
                    replyData.reply._u.subtraction._d = 1;
                    replyData.reply._u.subtraction._u.sysx_ = (SystemExceptionCode)SERVER_INTERNAL_ERROR;

                    _protocol.Calculator_se->sendReply(&replyData);
                }

                Calculator_Request_finalize(&requestData);


                }
                break;
                
    };        
}
DDS_Long CalculatorProtocol::Calculator_addition(/*in*/ DDS_Long value1, /*in*/ DDS_Long value2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    DDS_Long  return_ = 0;
    Calculator_Request instance;
    Calculator_Reply retInstance;

    Calculator_Reply_initialize(&retInstance);

    instance.request._d = 0xCBC6CEAA;
    
    instance.request._u.addition.value1 = value1;
    instance.request._u.addition.value2 = value2;

    retcode = Calculator_pe->send(&instance, &retInstance);
    
    if(retcode == OK)
    {
        switch (retInstance.reply._u.addition._d)
        {
            case 0:
		        return_ = retInstance.reply._u.addition._u.out_.return_;
                break;
            case 1:
                retcode = (eprosima::rpc::ReturnMessage)retInstance.reply._u.addition._u.sysx_;
                break;
            default:
                throw ClientInternalException("Error extracting information from server");
        }
    }
      
    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };
    

    return return_;
}
void CalculatorProtocol::Calculator_addition_async(Calculator_additionCallbackHandler &obj, /*in*/ DDS_Long value1, /*in*/ DDS_Long value2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    Calculator_Request instance;
    Calculator_additionTask *task = new Calculator_additionTask(obj);

    instance.request._d = 0xCBC6CEAA;
    
    instance.request._u.addition.value1 = value1;
    instance.request._u.addition.value2 = value2;

    retcode = Calculator_pe->send_async(&instance, task);
    
    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}

DDS_Long CalculatorProtocol::Calculator_subtraction(/*in*/ DDS_Long value1, /*in*/ DDS_Long value2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    DDS_Long  return_ = 0;
    Calculator_Request instance;
    Calculator_Reply retInstance;

    Calculator_Reply_initialize(&retInstance);

    instance.request._d = 0xCA019A14;
    
    instance.request._u.subtraction.value1 = value1;
    instance.request._u.subtraction.value2 = value2;

    retcode = Calculator_pe->send(&instance, &retInstance);
    
    if(retcode == OK)
    {
        switch (retInstance.reply._u.subtraction._d)
        {
            case 0:
		        return_ = retInstance.reply._u.subtraction._u.out_.return_;
                break;
            case 1:
                retcode = (eprosima::rpc::ReturnMessage)retInstance.reply._u.subtraction._u.sysx_;
                break;
            default:
                throw ClientInternalException("Error extracting information from server");
        }
    }
      
    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };
    

    return return_;
}
void CalculatorProtocol::Calculator_subtraction_async(Calculator_subtractionCallbackHandler &obj, /*in*/ DDS_Long value1, /*in*/ DDS_Long value2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    Calculator_Request instance;
    Calculator_subtractionTask *task = new Calculator_subtractionTask(obj);

    instance.request._d = 0xCA019A14;
    
    instance.request._u.subtraction.value1 = value1;
    instance.request._u.subtraction.value2 = value2;

    retcode = Calculator_pe->send_async(&instance, task);
    
    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



