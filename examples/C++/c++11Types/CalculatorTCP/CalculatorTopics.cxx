/*************************************************************************
 * Copyright (c) 2012 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * FASTRPC_LICENSE file included in this FASTRPC distribution.
 *
 *************************************************************************
 * 
 * @file CalculatorTopics.cpp
 * This source file contains the implementation of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "CalculatorTopics.h"

#include "fastcdr/Cdr.h"
#include "rpcdds/exceptions/BadParamException.h"

Calculator_additionRequest::Calculator_additionRequest()
: m_value1(0), m_value2(0)
{
}

Calculator_additionRequest::~Calculator_additionRequest()
{
}

Calculator_additionRequest::Calculator_additionRequest(const Calculator_additionRequest &x)
: m_value1(x.m_value1), m_value2(x.m_value2)
{
}

Calculator_additionRequest::Calculator_additionRequest(Calculator_additionRequest &&x)
: m_value1(std::move(x.m_value1)), m_value2(std::move(x.m_value2))
{
}

Calculator_additionRequest& Calculator_additionRequest::operator=(const Calculator_additionRequest &x)
{
    m_value1 = x.m_value1;;
    m_value2 = x.m_value2;;
    
    return *this;
}

Calculator_additionRequest& Calculator_additionRequest::operator=(Calculator_additionRequest &&x)
{
    m_value1 = x.m_value1;;
    m_value2 = x.m_value2;;
    
    return *this;
}

size_t Calculator_additionRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

size_t Calculator_additionRequest::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

void Calculator_additionRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_value1;

    scdr << m_value2;

}

void Calculator_additionRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_value1;
    dcdr >> m_value2;
}

Calculator_additionReply::Calculator_additionReply()
: m_addition_ret(0)
{
}

Calculator_additionReply::~Calculator_additionReply()
{
}

Calculator_additionReply::Calculator_additionReply(const Calculator_additionReply &x)
: m_addition_ret(x.m_addition_ret)
{
}

Calculator_additionReply::Calculator_additionReply(Calculator_additionReply &&x)
: m_addition_ret(std::move(x.m_addition_ret))
{
}

Calculator_additionReply& Calculator_additionReply::operator=(const Calculator_additionReply &x)
{
    m_addition_ret = x.m_addition_ret;;
    
    return *this;
}

Calculator_additionReply& Calculator_additionReply::operator=(Calculator_additionReply &&x)
{
    m_addition_ret = x.m_addition_ret;;
    
    return *this;
}

size_t Calculator_additionReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

size_t Calculator_additionReply::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

void Calculator_additionReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_addition_ret;

}

void Calculator_additionReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_addition_ret;
}

Calculator_subtractionRequest::Calculator_subtractionRequest()
: m_value1(0), m_value2(0)
{
}

Calculator_subtractionRequest::~Calculator_subtractionRequest()
{
}

Calculator_subtractionRequest::Calculator_subtractionRequest(const Calculator_subtractionRequest &x)
: m_value1(x.m_value1), m_value2(x.m_value2)
{
}

Calculator_subtractionRequest::Calculator_subtractionRequest(Calculator_subtractionRequest &&x)
: m_value1(std::move(x.m_value1)), m_value2(std::move(x.m_value2))
{
}

Calculator_subtractionRequest& Calculator_subtractionRequest::operator=(const Calculator_subtractionRequest &x)
{
    m_value1 = x.m_value1;;
    m_value2 = x.m_value2;;
    
    return *this;
}

Calculator_subtractionRequest& Calculator_subtractionRequest::operator=(Calculator_subtractionRequest &&x)
{
    m_value1 = x.m_value1;;
    m_value2 = x.m_value2;;
    
    return *this;
}

size_t Calculator_subtractionRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

size_t Calculator_subtractionRequest::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

void Calculator_subtractionRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_value1;

    scdr << m_value2;

}

void Calculator_subtractionRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_value1;
    dcdr >> m_value2;
}

Calculator_subtractionReply::Calculator_subtractionReply()
: m_subtraction_ret(0)
{
}

Calculator_subtractionReply::~Calculator_subtractionReply()
{
}

Calculator_subtractionReply::Calculator_subtractionReply(const Calculator_subtractionReply &x)
: m_subtraction_ret(x.m_subtraction_ret)
{
}

Calculator_subtractionReply::Calculator_subtractionReply(Calculator_subtractionReply &&x)
: m_subtraction_ret(std::move(x.m_subtraction_ret))
{
}

Calculator_subtractionReply& Calculator_subtractionReply::operator=(const Calculator_subtractionReply &x)
{
    m_subtraction_ret = x.m_subtraction_ret;;
    
    return *this;
}

Calculator_subtractionReply& Calculator_subtractionReply::operator=(Calculator_subtractionReply &&x)
{
    m_subtraction_ret = x.m_subtraction_ret;;
    
    return *this;
}

size_t Calculator_subtractionReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

size_t Calculator_subtractionReply::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

    return current_align;
}

void Calculator_subtractionReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_subtraction_ret;

}

void Calculator_subtractionReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_subtraction_ret;
}


CalculatorRequest_union::CalculatorRequest_union() : m__d(1)
{
}

CalculatorRequest_union::~CalculatorRequest_union()
{
}

CalculatorRequest_union::CalculatorRequest_union(const CalculatorRequest_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = x.m_addition;
                    break;
                
                case 2:
                    m_subtraction = x.m_subtraction;
                    break;
                
    }
}

CalculatorRequest_union::CalculatorRequest_union(CalculatorRequest_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = std::move(x.m_addition);
                    break;
                
                case 2:
                    m_subtraction = std::move(x.m_subtraction);
                    break;
                
    }
}

CalculatorRequest_union& CalculatorRequest_union::operator=(const CalculatorRequest_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = x.m_addition;
                    break;
                
                case 2:
                    m_subtraction = x.m_subtraction;
                    break;
                
    }
    
    return *this;
}

CalculatorRequest_union& CalculatorRequest_union::operator=(CalculatorRequest_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = std::move(x.m_addition);
                    break;
                
                case 2:
                    m_subtraction = std::move(x.m_subtraction);
                    break;
                
    }
    
    return *this;
}

void CalculatorRequest_union::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t CalculatorRequest_union::_d() const
{
    return m__d;
}

int32_t& CalculatorRequest_union::_d()
{
    return m__d;
}

void CalculatorRequest_union::addition(const Calculator_additionRequest &_addition)
{
    m_addition = _addition;
    m__d = 1;
}

void CalculatorRequest_union::addition(Calculator_additionRequest &&_addition)
{
    m_addition = std::move(_addition);
    m__d = 1;
}

const Calculator_additionRequest& CalculatorRequest_union::addition() const
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_addition;
}

Calculator_additionRequest& CalculatorRequest_union::addition()
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_addition;
}

void CalculatorRequest_union::subtraction(const Calculator_subtractionRequest &_subtraction)
{
    m_subtraction = _subtraction;
    m__d = 2;
}

void CalculatorRequest_union::subtraction(Calculator_subtractionRequest &&_subtraction)
{
    m_subtraction = std::move(_subtraction);
    m__d = 2;
}

const Calculator_subtractionRequest& CalculatorRequest_union::subtraction() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_subtraction;
}

Calculator_subtractionRequest& CalculatorRequest_union::subtraction()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_subtraction;
}


size_t CalculatorRequest_union::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    size_t reset_align = 0;
    size_t union_max_size_serialized = 0;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

        reset_align = current_align;

        reset_align = Calculator_additionRequest::getMaxCdrSerializedSize(reset_align);

        if(union_max_size_serialized < reset_align)
            union_max_size_serialized = reset_align;

        
        reset_align = current_align;

        reset_align = Calculator_subtractionRequest::getMaxCdrSerializedSize(reset_align);

        if(union_max_size_serialized < reset_align)
            union_max_size_serialized = reset_align;

        

    return union_max_size_serialized;
}

size_t CalculatorRequest_union::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void CalculatorRequest_union::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case 1:
                    scdr << m_addition;
                    break;
                
                case 2:
                    scdr << m_subtraction;
                    break;
                
    }
}

void CalculatorRequest_union::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case 1:
                    dcdr >> m_addition;
                    break;
                
                case 2:
                    dcdr >> m_subtraction;
                    break;
                
    }
}

CalculatorRequest::CalculatorRequest()
{
}

CalculatorRequest::~CalculatorRequest()
{
}

CalculatorRequest::CalculatorRequest(const CalculatorRequest &x)
: m__header(x.m__header), m_unio(x.m_unio)
{
}

CalculatorRequest::CalculatorRequest(CalculatorRequest &&x)
: m__header(std::move(x.m__header)), m_unio(std::move(x.m_unio))
{
}

CalculatorRequest& CalculatorRequest::operator=(const CalculatorRequest &x)
{
    m__header = x.m__header;
    m_unio = x.m_unio;
    
    return *this;
}

CalculatorRequest& CalculatorRequest::operator=(CalculatorRequest &&x)
{
    m__header = std::move(x.m__header);
    m_unio = std::move(x.m_unio);
    
    return *this;
}

size_t CalculatorRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    current_align =  eprosima::rpc::protocol::dds::RequestHeader::getMaxCdrSerializedSize(current_align);
    current_align = CalculatorRequest_union::getMaxCdrSerializedSize(current_align);
            
    return current_align;
}

size_t CalculatorRequest::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header and unio

    return current_align;
}

void CalculatorRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__header;
    scdr << m_unio;
}

void CalculatorRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__header;
    dcdr >> m_unio;
}

CalculatorReply_union::CalculatorReply_union() : m__d(1)
{
}

CalculatorReply_union::~CalculatorReply_union()
{
}

CalculatorReply_union::CalculatorReply_union(const CalculatorReply_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = x.m_addition;
                    break;
                
                case 2:
                    m_subtraction = x.m_subtraction;
                    break;
                
    }
}

CalculatorReply_union::CalculatorReply_union(CalculatorReply_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = std::move(x.m_addition);
                    break;
                
                case 2:
                    m_subtraction = std::move(x.m_subtraction);
                    break;
                
    }
}

CalculatorReply_union& CalculatorReply_union::operator=(const CalculatorReply_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = x.m_addition;
                    break;
                
                case 2:
                    m_subtraction = x.m_subtraction;
                    break;
                
    }
    
    return *this;
}

CalculatorReply_union& CalculatorReply_union::operator=(CalculatorReply_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case 1:
                    m_addition = std::move(x.m_addition);
                    break;
                
                case 2:
                    m_subtraction = std::move(x.m_subtraction);
                    break;
                
    }
    
    return *this;
}

void CalculatorReply_union::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t CalculatorReply_union::_d() const
{
    return m__d;
}

int32_t& CalculatorReply_union::_d()
{
    return m__d;
}

void CalculatorReply_union::addition(const Calculator_additionReply &_addition)
{
    m_addition = _addition;
    m__d = 1;
}

void CalculatorReply_union::addition(Calculator_additionReply &&_addition)
{
    m_addition = std::move(_addition);
    m__d = 1;
}

const Calculator_additionReply& CalculatorReply_union::addition() const
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_addition;
}

Calculator_additionReply& CalculatorReply_union::addition()
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_addition;
}

void CalculatorReply_union::subtraction(const Calculator_subtractionReply &_subtraction)
{
    m_subtraction = _subtraction;
    m__d = 2;
}

void CalculatorReply_union::subtraction(Calculator_subtractionReply &&_subtraction)
{
    m_subtraction = std::move(_subtraction);
    m__d = 2;
}

const Calculator_subtractionReply& CalculatorReply_union::subtraction() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_subtraction;
}

Calculator_subtractionReply& CalculatorReply_union::subtraction()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_subtraction;
}


size_t CalculatorReply_union::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    size_t reset_align = 0;
    size_t union_max_size_serialized = 0;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

        reset_align = current_align;

        reset_align = Calculator_additionReply::getMaxCdrSerializedSize(reset_align);

        if(union_max_size_serialized < reset_align)
            union_max_size_serialized = reset_align;

        
        reset_align = current_align;

        reset_align = Calculator_subtractionReply::getMaxCdrSerializedSize(reset_align);

        if(union_max_size_serialized < reset_align)
            union_max_size_serialized = reset_align;

        

    return union_max_size_serialized;
}

size_t CalculatorReply_union::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void CalculatorReply_union::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case 1:
                    scdr << m_addition;
                    break;
                
                case 2:
                    scdr << m_subtraction;
                    break;
                
    }
}

void CalculatorReply_union::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case 1:
                    dcdr >> m_addition;
                    break;
                
                case 2:
                    dcdr >> m_subtraction;
                    break;
                
    }
}

CalculatorReply::CalculatorReply()
{
}

CalculatorReply::~CalculatorReply()
{
}

CalculatorReply::CalculatorReply(const CalculatorReply &x)
: m__header(x.m__header), m_unio(x.m_unio)
{
}

CalculatorReply::CalculatorReply(CalculatorReply &&x)
: m__header(std::move(x.m__header)), m_unio(std::move(x.m_unio))
{
}

CalculatorReply& CalculatorReply::operator=(const CalculatorReply &x)
{
    m__header = x.m__header;
    m_unio = x.m_unio;
    
    return *this;
}

CalculatorReply& CalculatorReply::operator=(CalculatorReply &&x)
{
    m__header = std::move(x.m__header);
    m_unio = std::move(x.m_unio);
    
    return *this;
}

size_t CalculatorReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    current_align =  eprosima::rpc::protocol::dds::ReplyHeader::getMaxCdrSerializedSize(current_align);
    current_align = CalculatorReply_union::getMaxCdrSerializedSize(current_align);
            
    return current_align;
}

size_t CalculatorReply::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header and unio

    return current_align;
}

void CalculatorReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__header;
    scdr << m_unio;
}

void CalculatorReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__header;
    dcdr >> m_unio;
}
